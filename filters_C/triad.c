/*******************************************************************************
 * TRIAD姿态解算算法 - C语言实现
 * 
 * 算法简介：
 * ==============================================================================
 * TRIAD (TRI-Axial Attitude Determination) 是最早的姿态确定算法之一，
 * 由Harold Black于1964年提出。它是一种代数方法，可以从两个非平行的
 * 矢量观测直接计算出姿态矩阵。
 * 
 * 算法特点：
 * 1. 纯代数解法，无需迭代优化
 * 2. 计算量小，速度快
 * 3. 只需两组矢量观测即可确定姿态
 * 4. 不需要初始值
 * 5. 没有收敛问题
 * 6. 适合作为其他算法的初始化
 * 
 * 
 * 算法原理：
 * ==============================================================================
 * 
 * 基本问题
 * ---------
 * 
 * 已知：
 *   - 参考坐标系的两个单位向量：v1, v2
 *   - 对应的测量坐标系的两个单位向量：w1, w2
 * 
 * 求：
 *   - 旋转矩阵 A，使得：A·v1 ≈ w1, A·v2 ≈ w2
 * 
 * 
 * 构造正交三元组
 * ---------------
 * 
 * 参考坐标系三元组（Reference Triad）：
 *   q_r = v1                    （第一轴：直接使用第一个参考向量）
 *   r_r = (v1 × v2) / |v1 × v2|  （第二轴：两向量叉乘归一化）
 *   s_r = q_r × r_r              （第三轴：前两轴叉乘）
 * 
 * 测量坐标系三元组（Body Triad）：
 *   q_b = w1
 *   r_b = (w1 × w2) / |w1 × w2|
 *   s_b = q_b × r_b
 * 
 * 这样构造出两组正交标准基。
 * 
 * 
 * 旋转矩阵求解
 * -------------
 * 
 * 定义矩阵：
 *   M_r = [q_r | r_r | s_r]  （参考坐标系的基矩阵，3x3）
 *   M_b = [q_b | r_b | s_b]  （测量坐标系的基矩阵，3x3）
 * 
 * 姿态矩阵：
 *   A = M_b · M_r^T
 * 
 * 因为M_r是正交矩阵，所以 M_r^(-1) = M_r^T
 * 
 * 
 * 应用于IMU/MARG
 * ---------------
 * 
 * 对于惯性导航系统：
 * 
 * 参考向量（地球坐标系）：
 *   v1 = [0, 0, 1]       重力方向（指向下，NED坐标系）
 *   v2 = [bx, 0, bz]     磁场方向（北向分量和垂直分量）
 * 
 * 测量向量（传感器坐标系）：
 *   w1 = [ax, ay, az]    加速度计测量（归一化）
 *   w2 = [mx, my, mz]    磁力计测量（归一化）
 * 
 * 
 * 算法优势：
 * ==============================================================================
 * 
 * 1. 一次性求解：
 *    不需要迭代，一步到位得到姿态
 * 
 * 2. 计算稳定：
 *    纯代数运算，数值稳定性好
 * 
 * 3. 不需要先验：
 *    无需提供初始姿态估计
 * 
 * 4. 实时性好：
 *    计算量固定且小，适合高频率更新
 * 
 * 
 * 算法局限：
 * ==============================================================================
 * 
 * 1. 只能用于静态或准静态：
 *    假设w1纯粹是重力，w2纯粹是磁场
 *    有运动加速度时会产生误差
 * 
 * 2. 没有滤波：
 *    每次独立计算，不利用历史信息
 *    对传感器噪声敏感
 * 
 * 3. 两个向量权重相同：
 *    无法根据置信度调整
 * 
 * 4. 向量必须非平行：
 *    如果v1和v2接近平行，叉乘会接近零，导致数值问题
 * 
 * 
 * 典型应用：
 * ==============================================================================
 * 
 * 1. 姿态初始化：
 *    为Madgwick、Mahony等算法提供初始姿态
 * 
 * 2. 静态姿态测量：
 *    传感器静止时的快速姿态估计
 * 
 * 3. 粗略姿态估计：
 *    对精度要求不高但需要快速的场合
 * 
 * 4. 算法对比参考：
 *    作为基准测试其他算法的性能
 * 
 * 
 * 与其他算法对比：
 * ==============================================================================
 * 
 * TRIAD vs QUEST：
 *   - TRIAD：简单快速，但只用两个向量
 *   - QUEST：可以用多个向量，精度更高，但需要迭代
 * 
 * TRIAD vs 互补滤波：
 *   - TRIAD：瞬时解，无滤波
 *   - 互补滤波：融合历史，平滑输出
 * 
 * TRIAD vs Madgwick/Mahony：
 *   - TRIAD：静态精度高
 *   - Madgwick/Mahony：动态跟踪好
 * 
 * 
 * 使用建议：
 * ==============================================================================
 * 
 * 1. 初始化其他滤波器：
 *    先用TRIAD计算初始姿态，再传给Madgwick/Mahony
 * 
 * 2. 结合滤波器使用：
 *    TRIAD提供瞬时姿态 → 滤波器平滑 → 最终输出
 * 
 * 3. 检测静态：
 *    当检测到传感器静止，用TRIAD重置滤波器，消除漂移
 * 
 * 
 * 使用示例：
 * ==============================================================================
 * 
 * float acc[3] = {ax, ay, az};  // 加速度计数据
 * float mag[3] = {mx, my, mz};  // 磁力计数据
 * float q[4];                    // 输出四元数
 * 
 * // 直接计算姿态
 * triad(acc, mag, q);
 * 
 * // 或者先转换为旋转矩阵
 * float R[9];
 * triad_to_dcm(acc, mag, R);
 * // 再从旋转矩阵转为四元数...
 * 
 * 
 * 注意事项：
 * ==============================================================================
 * 1. 输入向量必须归一化
 * 2. 两个参考向量（重力和磁场）不能平行
 * 3. 仅适用于静态或低动态环境
 * 4. 对传感器噪声敏感，建议结合滤波器使用
 * 5. 磁力计必须经过校准
 * 
 ******************************************************************************/

#include <math.h>

/*===========================================================================*/
/*                            辅助数学函数                                    */
/*===========================================================================*/

/**
 * @brief 向量归一化
 */
static void normalize(float *v, int n) {
    float norm = 0.0f;
    int i;
    for (i = 0; i < n; i++) {
        norm += v[i] * v[i];
    }
    norm = sqrtf(norm);
    if (norm > 0.0f) {
        for (i = 0; i < n; i++) {
            v[i] /= norm;
        }
    }
}

/**
 * @brief 向量叉乘 c = a × b
 */
static void cross_product(const float *a, const float *b, float *c) {
    c[0] = a[1]*b[2] - a[2]*b[1];
    c[1] = a[2]*b[0] - a[0]*b[2];
    c[2] = a[0]*b[1] - a[1]*b[0];
}

/**
 * @brief 旋转矩阵转四元数
 * 
 * 使用Shepperd方法，选择最大的四元数分量计算，避免数值问题
 * 
 * @param R 旋转矩阵（3x3，按行存储）
 * @param q 输出四元数 [qw, qx, qy, qz]
 */
static void dcm_to_quaternion(const float *R, float *q) {
    float trace = R[0] + R[4] + R[8];  // R[0,0] + R[1,1] + R[2,2]
    
    if (trace > 0.0f) {
        /* qw 最大 */
        float s = sqrtf(trace + 1.0f) * 2.0f;  // s = 4*qw
        q[0] = 0.25f * s;
        q[1] = (R[7] - R[5]) / s;  // (R[2,1] - R[1,2]) / s
        q[2] = (R[2] - R[6]) / s;  // (R[0,2] - R[2,0]) / s
        q[3] = (R[3] - R[1]) / s;  // (R[1,0] - R[0,1]) / s
    } else if ((R[0] > R[4]) && (R[0] > R[8])) {
        /* qx 最大 */
        float s = sqrtf(1.0f + R[0] - R[4] - R[8]) * 2.0f;  // s = 4*qx
        q[0] = (R[7] - R[5]) / s;
        q[1] = 0.25f * s;
        q[2] = (R[1] + R[3]) / s;
        q[3] = (R[2] + R[6]) / s;
    } else if (R[4] > R[8]) {
        /* qy 最大 */
        float s = sqrtf(1.0f + R[4] - R[0] - R[8]) * 2.0f;  // s = 4*qy
        q[0] = (R[2] - R[6]) / s;
        q[1] = (R[1] + R[3]) / s;
        q[2] = 0.25f * s;
        q[3] = (R[5] + R[7]) / s;
    } else {
        /* qz 最大 */
        float s = sqrtf(1.0f + R[8] - R[0] - R[4]) * 2.0f;  // s = 4*qz
        q[0] = (R[3] - R[1]) / s;
        q[1] = (R[2] + R[6]) / s;
        q[2] = (R[5] + R[7]) / s;
        q[3] = 0.25f * s;
    }
    
    /* 归一化四元数 */
    normalize(q, 4);
}

/*===========================================================================*/
/*                         TRIAD算法核心函数                                  */
/*===========================================================================*/

/**
 * @brief TRIAD算法 - 计算旋转矩阵（方向余弦矩阵）
 * 
 * 从两组向量观测计算姿态矩阵
 * 
 * 算法步骤：
 * 1. 归一化输入向量
 * 2. 构造参考坐标系三元组 (q_r, r_r, s_r)
 * 3. 构造测量坐标系三元组 (q_b, r_b, s_b)
 * 4. 计算旋转矩阵 A = M_b · M_r^T
 * 
 * @param w1 测量向量1（如加速度计），归一化前
 * @param w2 测量向量2（如磁力计），归一化前
 * @param v1 参考向量1（如重力方向 [0,0,1]）
 * @param v2 参考向量2（如磁场方向 [bx,0,bz]）
 * @param R 输出的旋转矩阵（3x3，按行存储）
 */
void triad_to_dcm(const float *w1, const float *w2, 
                  const float *v1, const float *v2, float *R) {
    float w1_norm[3], w2_norm[3];
    float v1_norm[3], v2_norm[3];
    int i;
    
    /* 步骤1: 归一化测量向量 */
    for (i = 0; i < 3; i++) {
        w1_norm[i] = w1[i];
        w2_norm[i] = w2[i];
        v1_norm[i] = v1[i];
        v2_norm[i] = v2[i];
    }
    normalize(w1_norm, 3);
    normalize(w2_norm, 3);
    normalize(v1_norm, 3);
    normalize(v2_norm, 3);
    
    /* 步骤2: 构造参考坐标系三元组 M_r */
    float q_r[3], r_r[3], s_r[3];
    
    // q_r = v1 （第一轴直接使用v1）
    for (i = 0; i < 3; i++) q_r[i] = v1_norm[i];
    
    // r_r = (v1 × v2) / |v1 × v2| （第二轴是叉乘）
    cross_product(v1_norm, v2_norm, r_r);
    normalize(r_r, 3);
    
    // s_r = q_r × r_r （第三轴）
    cross_product(q_r, r_r, s_r);
    
    /* 步骤3: 构造测量坐标系三元组 M_b */
    float q_b[3], r_b[3], s_b[3];
    
    // q_b = w1
    for (i = 0; i < 3; i++) q_b[i] = w1_norm[i];
    
    // r_b = (w1 × w2) / |w1 × w2|
    cross_product(w1_norm, w2_norm, r_b);
    normalize(r_b, 3);
    
    // s_b = q_b × r_b
    cross_product(q_b, r_b, s_b);
    
    /* 步骤4: 计算旋转矩阵 A = M_b · M_r^T */
    /* 
     * M_b = [q_b | r_b | s_b], M_r = [q_r | r_r | s_r]
     * A[i][j] = M_b的第i行 · M_r的第j行
     *         = (M_b的第i列) · (M_r的第j列)
     */
    
    /* 第一行 */
    R[0] = q_b[0]*q_r[0] + r_b[0]*r_r[0] + s_b[0]*s_r[0];  // A[0,0]
    R[1] = q_b[0]*q_r[1] + r_b[0]*r_r[1] + s_b[0]*s_r[1];  // A[0,1]
    R[2] = q_b[0]*q_r[2] + r_b[0]*r_r[2] + s_b[0]*s_r[2];  // A[0,2]
    
    /* 第二行 */
    R[3] = q_b[1]*q_r[0] + r_b[1]*r_r[0] + s_b[1]*s_r[0];  // A[1,0]
    R[4] = q_b[1]*q_r[1] + r_b[1]*r_r[1] + s_b[1]*s_r[1];  // A[1,1]
    R[5] = q_b[1]*q_r[2] + r_b[1]*r_r[2] + s_b[1]*s_r[2];  // A[1,2]
    
    /* 第三行 */
    R[6] = q_b[2]*q_r[0] + r_b[2]*r_r[0] + s_b[2]*s_r[0];  // A[2,0]
    R[7] = q_b[2]*q_r[1] + r_b[2]*r_r[1] + s_b[2]*s_r[1];  // A[2,1]
    R[8] = q_b[2]*q_r[2] + r_b[2]*r_r[2] + s_b[2]*s_r[2];  // A[2,2]
}

/**
 * @brief TRIAD算法 - 直接计算四元数
 * 
 * 这是triad_to_dcm的便捷封装，直接输出四元数
 * 
 * @param w1 测量向量1（如加速度计）
 * @param w2 测量向量2（如磁力计）
 * @param v1 参考向量1（如重力方向）
 * @param v2 参考向量2（如磁场方向）
 * @param q 输出四元数 [qw, qx, qy, qz]
 */
void triad(const float *w1, const float *w2, 
           const float *v1, const float *v2, float *q) {
    float R[9];
    
    /* 步骤1: 计算旋转矩阵 */
    triad_to_dcm(w1, w2, v1, v2, R);
    
    /* 步骤2: 转换为四元数 */
    dcm_to_quaternion(R, q);
}

/**
 * @brief TRIAD算法 - IMU/MARG应用的便捷接口
 * 
 * 专门用于惯性导航的TRIAD，自动设置参考向量：
 *   - 重力： [0, 0, 1] (NED坐标系，向下为正)
 *   - 磁场： 从磁倾角计算
 * 
 * @param acc 加速度计测量 [ax, ay, az]
 * @param mag 磁力计测量 [mx, my, mz]
 * @param mag_dip 磁倾角 (度)，用于构造参考磁场
 * @param q 输出四元数 [qw, qx, qy, qz]
 */
void triad_imu(const float *acc, const float *mag, float mag_dip, float *q) {
    /* 参考重力向量（NED坐标系） */
    float v_gravity[3] = {0.0f, 0.0f, 1.0f};
    
    /* 参考磁场向量（从磁倾角计算） */
    float dip_rad = mag_dip * M_PI / 180.0f;
    float v_mag[3];
    v_mag[0] = cosf(dip_rad);  // 北向分量
    v_mag[1] = 0.0f;           // 东向分量（忽略）
    v_mag[2] = sinf(dip_rad);  // 下向分量
    
    /* 调用TRIAD算法 */
    triad(acc, mag, v_gravity, v_mag, q);
}

/*===========================================================================*/
/*                                END OF FILE                                */
/*===========================================================================*/
