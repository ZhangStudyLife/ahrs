/*******************************************************************************
 * Complementary Filter (互补滤波器) - C语言实现
 * 
 * 算法简介：
 * ==============================================================================
 * 互补滤波器是最简单、最直观的姿态融合算法之一。它基于一个核心思想：
 * 不同传感器的误差特性是"互补"的，通过适当的融合可以相互补偿。
 * 
 * 算法特点：
 * 1. 算法极其简单，计算量小，适合资源受限的嵌入式系统
 * 2. 只有一个参数α（增益），调参非常容易
 * 3. 物理意义直观：低通滤波+高通滤波的组合
 * 4. 实时性好，无需迭代优化
 * 5. 对参数不敏感，鲁棒性好
 * 
 * 
 * 算法原理：
 * ==============================================================================
 * 
 * 传感器误差特性分析
 * -------------------
 * 
 * 陀螺仪特性：
 *   优点：
 *   - 动态响应快，高频特性好
 *   - 短时间内精度高
 *   
 *   缺点：
 *   - 存在零漂，长时间积分会产生累积误差
 *   - 低频误差大（漂移）
 * 
 * 加速度计特性：
 *   优点：
 *   - 长时间稳定，无累积误差
 *   - 低频特性好，可以提供绝对参考
 *   
 *   缺点：
 *   - 受运动加速度干扰
 *   - 高频噪声大
 *   - 只能测量倾角（Roll & Pitch），无法测量航向（Yaw）
 * 
 * 磁力计特性：
 *   优点：
 *   - 可以提供航向角参考
 *   - 长时间稳定
 *   
 *   缺点：
 *   - 容易受磁干扰
 *   - 响应慢
 * 
 * 
 * 互补性原理
 * -----------
 * 
 * 陀螺仪和加速度计的误差特性正好"互补"：
 *   - 陀螺仪：高频好 + 低频差
 *   - 加速度计：低频好 + 高频差
 * 
 * 互补滤波器的思路：
 *   姿态估计 = α·(陀螺仪估计) + (1-α)·(加速度计估计)
 * 
 *   其中：
 *   - α接近1：更相信陀螺仪（高频），适合动态环境
 *   - α接近0：更相信加速度计（低频），适合静态环境
 *   - 典型值：α = 0.95~0.98
 * 
 * 
 * 数学表达式
 * -----------
 * 
 * 1. 从加速度计计算倾角：
 * 
 *   θ_acc_x = arctan2(ay, az)                    // Roll角
 *   θ_acc_y = arctan2(-ax, √(ay² + az²))         // Pitch角
 *   θ_acc_z = 0                                  // Yaw角（加速度计无法测量）
 * 
 * 2. 从陀螺仪积分姿态：
 * 
 *   θ_gyr(t) = θ(t-1) + ω·Δt
 * 
 *   其中 ω = [ωx, ωy, ωz] 是角速度
 * 
 * 3. 互补融合：
 * 
 *   θ(t) = α·θ_gyr(t) + (1-α)·θ_acc(t)
 * 
 * 4. 如果有磁力计，计算航向角：
 * 
 *   首先进行倾斜补偿：
 *   bx = mx·cos(θx) + my·sin(θx)·sin(θy) + mz·sin(θx)·cos(θy)
 *   by = my·cos(θy) - mz·sin(θy)
 *   
 *   然后计算航向：
 *   θ_mag_z = arctan2(-by, bx)
 * 
 * 
 * 频域理解（高级）
 * ================
 * 
 * 从频域看，互补滤波器相当于：
 * 
 *   H_gyr(s) = α/(1 + τs)        // 对陀螺仪：低通滤波器
 *   H_acc(s) = τs/(1 + τs)       // 对加速度计：高通滤波器
 * 
 * 其中 τ = α·Δt/(1-α) 是时间常数
 * 
 * 两个滤波器的传递函数之和恰好为1：
 *   H_gyr(s) + H_acc(s) = 1
 * 
 * 这就是"互补"的数学本质！
 * 
 * 
 * 参数调整指南：
 * ==============================================================================
 * 
 * 增益参数 α：
 *   - 典型范围：0.90 ~ 0.99
 *   - 推荐值：
 *     * 静态或慢速运动：α = 0.95
 *     * 动态运动：α = 0.98
 *     * 极高动态：α = 0.99
 * 
 *   - 调参建议：
 *     * α太小（如<0.9）：姿态会抖动（加速度计噪声）
 *     * α太大（如>0.99）：姿态会漂移（陀螺仪零漂）
 *     * 从0.95开始调，动态大就增加，漂移大就减小
 * 
 * 时间常数 τ = α·Δt/(1-α)：
 *   - 物理意义：滤波器的"记忆"时间
 *   - 举例（100Hz采样，Δt=0.01s）：
 *     * α=0.95 → τ=0.19s （快速响应）
 *     * α=0.98 → τ=0.49s （中等）
 *     * α=0.99 → τ=0.99s （慢速，平滑）
 * 
 * 
 * 优缺点分析：
 * ==============================================================================
 * 
 * 优点：
 *   1. 算法简单，代码量小（<100行）
 *   2. 计算量极小，适合低端MCU（如8位单片机）
 *   3. 只有一个参数，调参容易
 *   4. 无需矩阵运算，避免数值问题
 *   5. 实时性好，延迟小
 * 
 * 缺点：
 *   1. 精度不如高级算法（Madgwick, Mahony, EKF）
 *   2. 没有陀螺仪零偏估计
 *   3. 对加速度干扰敏感（动态环境下性能下降）
 *   4. 直接用欧拉角，存在万向节死锁风险
 * 
 * 
 * 适用场景：
 * ==============================================================================
 * 
 * 推荐使用：
 *   - 资源受限的嵌入式系统（如Arduino）
 *   - 对精度要求不高的应用
 *   - 静态或低动态环境
 *   - 快速原型开发和调试
 *   - 教学和学习姿态估计原理
 * 
 * 不推荐使用：
 *   - 高精度要求的应用（如无人机、机器人）
 *   - 高动态环境（频繁加速、急转弯）
 *   - 需要长时间稳定运行的系统
 * 
 * 
 * 改进建议：
 * ==============================================================================
 * 
 * 如果互补滤波器不够用，可以考虑：
 * 
 * 1. 动态调整α：
 *    根据加速度计的大小动态调整信任度
 *    if (|a| ≈ 9.8m/s²) then 增加加速度计权重
 *    else 减少权重（运动加速度干扰）
 * 
 * 2. 添加陀螺仪零偏估计：
 *    在静止时估计零偏并减去
 * 
 * 3. 升级到更好的算法：
 *    - Mahony滤波器：加入PI控制和零偏估计
 *    - Madgwick算法：梯度下降优化
 *    - EKF/UKF：最优估计
 * 
 * 
 * 使用示例：
 * ==============================================================================
 * 
 * // 初始化
 * float angles[3] = {0.0f, 0.0f, 0.0f};  // Roll, Pitch, Yaw
 * float gyr[3], acc[3], mag[3];           // 传感器数据
 * float dt = 0.01f;                       // 采样周期 100Hz
 * float alpha = 0.95f;                    // 滤波器增益
 * 
 * // 主循环
 * while (运行) {
 *     读取传感器(gyr, acc, mag);
 *     
 *     // IMU更新（无磁力计）
 *     complementary_filter_imu(angles, gyr, acc, alpha, dt);
 *     
 *     // 或 MARG更新（有磁力计）
 *     complementary_filter_marg(angles, gyr, acc, mag, alpha, dt);
 * }
 * 
 * 
 * 注意事项：
 * ==============================================================================
 * 1. 建议采样频率 ≥100Hz，否则效果会变差
 * 2. 加速度计必须校准（消除偏置）
 * 3. 磁力计必须校准（软铁/硬铁补偿）
 * 4. 初始姿态建议在静止状态下从传感器计算
 * 5. 欧拉角在±90°附近可能不准确（万向节死锁）
 * 
 ******************************************************************************/

#include <math.h>

/*===========================================================================*/
/*                            辅助数学函数                                    */
/*===========================================================================*/

/**
 * @brief 安全的反正切函数 atan2
 * 处理边界情况，避免除零
 */
static float safe_atan2(float y, float x) {
    if (x == 0.0f && y == 0.0f)
        return 0.0f;
    return atan2f(y, x);
}

/**
 * @brief 安全的反正弦函数 asin
 * 将输入限制在[-1, 1]范围内
 */
static float safe_asin(float x) {
    if (x > 1.0f) x = 1.0f;
    if (x < -1.0f) x = -1.0f;
    return asinf(x);
}

/*===========================================================================*/
/*                    从加速度计计算倾角（静态姿态）                           */
/*===========================================================================*/

/**
 * @brief 从加速度计测量计算倾角（Roll和Pitch）
 * 
 * 原理：
 *   在静止或匀速运动时，加速度计测量的是重力分量。
 *   通过重力在各轴的投影，可以计算出倾角。
 * 
 * 公式推导：
 *   假设重力向量 g = [0, 0, 9.8]（地球坐标系）
 *   经过Roll(φ)和Pitch(θ)旋转后在传感器坐标系的投影为：
 *   
 *   ax = -g·sin(θ)
 *   ay =  g·sin(φ)·cos(θ)
 *   az =  g·cos(φ)·cos(θ)
 *   
 *   反解得：
 *   φ = arctan2(ay, az)
 *   θ = arctan2(-ax, √(ay²+az²))
 * 
 * @param acc 加速度计测量 [ax, ay, az]
 * @param angles_out 输出的倾角 [roll, pitch, yaw] (弧度)
 *                   注意：yaw设为0（加速度计无法测量航向）
 */
static void acc_to_angles(const float *acc, float *angles_out) {
    float ax = acc[0], ay = acc[1], az = acc[2];
    
    /* Roll角 (绕X轴旋转) */
    angles_out[0] = safe_atan2(ay, az);
    
    /* Pitch角 (绕Y轴旋转) */
    float pitch_denom = sqrtf(ay*ay + az*az);
    angles_out[1] = safe_atan2(-ax, pitch_denom);
    
    /* Yaw角 (加速度计无法测量，设为0) */
    angles_out[2] = 0.0f;
}

/*===========================================================================*/
/*                  从磁力计计算航向角（需要倾斜补偿）                         */
/*===========================================================================*/

/**
 * @brief 从磁力计测量计算航向角（需要已知的Roll和Pitch）
 * 
 * 原理：
 *   磁力计测量的是地磁场在传感器坐标系的投影。
 *   但如果传感器倾斜，需要先进行倾斜补偿，将磁场向量
 *   旋转到水平面，然后才能计算航向角。
 * 
 * 倾斜补偿公式：
 *   设Roll=φ, Pitch=θ，磁力计测量为[mx, my, mz]
 *   
 *   补偿后的水平磁场分量：
 *   bx = mx·cos(φ) + my·sin(φ)·sin(θ) + mz·sin(φ)·cos(θ)
 *   by = my·cos(θ) - mz·sin(θ)
 *   
 *   航向角：
 *   ψ = arctan2(-by, bx)
 * 
 * 注意：
 *   - 需要先用加速度计得到准确的Roll和Pitch
 *   - 磁力计必须经过校准（消除硬铁和软铁干扰）
 * 
 * @param mag 磁力计测量 [mx, my, mz]
 * @param roll 当前Roll角 (弧度)
 * @param pitch 当前Pitch角 (弧度)
 * @return 航向角Yaw (弧度)
 */
static float mag_to_yaw(const float *mag, float roll, float pitch) {
    float mx = mag[0], my = mag[1], mz = mag[2];
    float cos_roll = cosf(roll);
    float sin_roll = sinf(roll);
    float cos_pitch = cosf(pitch);
    float sin_pitch = sinf(pitch);
    
    /* 倾斜补偿 */
    float bx = mx*cos_roll + my*sin_roll*sin_pitch + mz*sin_roll*cos_pitch;
    float by = my*cos_pitch - mz*sin_pitch;
    
    /* 计算航向角 */
    float yaw = safe_atan2(-by, bx);
    
    return yaw;
}

/*===========================================================================*/
/*                   互补滤波器 - IMU版本（无磁力计）                         */
/*===========================================================================*/

/**
 * @brief 互补滤波器IMU姿态更新（仅使用陀螺仪和加速度计）
 * 
 * 算法流程：
 * 1. 从陀螺仪积分计算姿态变化
 * 2. 从加速度计计算倾角（静态参考）
 * 3. 互补融合两个估计
 * 
 * 融合公式：
 *   θ(t) = α·[θ(t-1) + ω·Δt] + (1-α)·θ_acc
 *        = α·θ_gyr + (1-α)·θ_acc
 * 
 * 注意：
 *   - Yaw角保持为0（加速度计无法测量航向）
 *   - 如需航向，请使用MARG版本（加磁力计）
 * 
 * @param angles 欧拉角 [roll, pitch, yaw]（输入输出，单位：弧度）
 * @param gyr 陀螺仪测量 [ωx, ωy, ωz] (rad/s)
 * @param acc 加速度计测量 [ax, ay, az]
 * @param alpha 滤波器增益，范围[0,1]，推荐0.95-0.98
 * @param dt 采样周期 (秒)
 */
void complementary_filter_imu(float *angles, const float *gyr, const float *acc,
                               float alpha, float dt) {
    float gx = gyr[0], gy = gyr[1], gz = gyr[2];
    
    /* 步骤1: 陀螺仪积分（预测） */
    /* θ_gyr = θ(t-1) + ω·Δt */
    float angles_gyr[3];
    angles_gyr[0] = angles[0] + gx * dt;  // Roll
    angles_gyr[1] = angles[1] + gy * dt;  // Pitch
    angles_gyr[2] = angles[2] + gz * dt;  // Yaw (但IMU模式无法修正，会漂移)
    
    /* 步骤2: 加速度计计算倾角（修正） */
    float angles_acc[3];
    acc_to_angles(acc, angles_acc);
    
    /* 步骤3: 互补融合（仅Roll和Pitch） */
    /* θ = α·θ_gyr + (1-α)·θ_acc */
    angles[0] = alpha * angles_gyr[0] + (1.0f - alpha) * angles_acc[0];  // Roll
    angles[1] = alpha * angles_gyr[1] + (1.0f - alpha) * angles_acc[1];  // Pitch
    
    /* Yaw角：只使用陀螺仪（IMU模式无参考，会漂移） */
    angles[2] = angles_gyr[2];
}

/*===========================================================================*/
/*                  互补滤波器 - MARG版本（含磁力计）                         */
/*===========================================================================*/

/**
 * @brief 互补滤波器MARG姿态更新（使用陀螺仪、加速度计和磁力计）
 * 
 * 算法流程：
 * 1. 从陀螺仪积分计算姿态变化
 * 2. 从加速度计计算倾角
 * 3. 从磁力计计算航向角（需倾斜补偿）
 * 4. 分别对Roll、Pitch、Yaw进行互补融合
 * 
 * 优势：
 *   - 相比IMU版本，Yaw角有参考，不会漂移
 *   - 可以估计完整的三维姿态
 * 
 * 注意：
 *   - 磁力计必须经过校准
 *   - 在磁干扰环境下，航向估计可能不准
 *   - 可以考虑检测磁场强度，异常时降低磁力计权重
 * 
 * @param angles 欧拉角 [roll, pitch, yaw]（输入输出，单位：弧度）
 * @param gyr 陀螺仪测量 [ωx, ωy, ωz] (rad/s)
 * @param acc 加速度计测量 [ax, ay, az]
 * @param mag 磁力计测量 [mx, my, mz]
 * @param alpha 滤波器增益，范围[0,1]，推荐0.95-0.98
 * @param dt 采样周期 (秒)
 */
void complementary_filter_marg(float *angles, const float *gyr, const float *acc,
                                const float *mag, float alpha, float dt) {
    float gx = gyr[0], gy = gyr[1], gz = gyr[2];
    
    /* 步骤1: 陀螺仪积分 */
    float angles_gyr[3];
    angles_gyr[0] = angles[0] + gx * dt;  // Roll
    angles_gyr[1] = angles[1] + gy * dt;  // Pitch
    angles_gyr[2] = angles[2] + gz * dt;  // Yaw
    
    /* 步骤2: 加速度计计算倾角 */
    float angles_acc[3];
    acc_to_angles(acc, angles_acc);
    
    /* 步骤3: 先融合Roll和Pitch（用于磁力计倾斜补偿） */
    angles[0] = alpha * angles_gyr[0] + (1.0f - alpha) * angles_acc[0];
    angles[1] = alpha * angles_gyr[1] + (1.0f - alpha) * angles_acc[1];
    
    /* 步骤4: 使用融合后的倾角，从磁力计计算航向 */
    float yaw_mag = mag_to_yaw(mag, angles[0], angles[1]);
    
    /* 步骤5: 融合航向角 */
    /* 注意：航向角可能跨越±π边界，需要特殊处理 */
    float yaw_diff = yaw_mag - angles_gyr[2];
    
    /* 处理角度跳变（-π到π的边界） */
    if (yaw_diff > M_PI) {
        yaw_diff -= 2.0f * M_PI;
    } else if (yaw_diff < -M_PI) {
        yaw_diff += 2.0f * M_PI;
    }
    
    angles[2] = angles_gyr[2] + (1.0f - alpha) * yaw_diff;
    
    /* 将Yaw角规范化到[-π, π] */
    while (angles[2] > M_PI) angles[2] -= 2.0f * M_PI;
    while (angles[2] < -M_PI) angles[2] += 2.0f * M_PI;
}

/*===========================================================================*/
/*                                END OF FILE                                */
/*===========================================================================*/
